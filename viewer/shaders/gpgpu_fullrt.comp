#version 430 core

layout(binding = 2, rgba32f) uniform image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform bool blinnPhong;
uniform bool transparent;
uniform float shininess;
uniform float eta;
uniform float radius;
uniform bool quasiRandom;
uniform float roughness; // addition for alpha
uniform float time; //for randomization

uniform float groundDistance;
uniform vec3 center;
#define MAX_HEIGHT 1080
#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001

#define MIN_DISTANCE EPS
#define GROUND_VPTR -1

#define M_1_PI 0.31830988618
#define PI 3.141592653589793

#define Ka 0.05
#define Kd 0.7


float haltons[256] =  float[256](
0.3333333333333333,
0.6666666666666666,
0.1111111111111111,
0.4444444444444444,
0.7777777777777778,
0.2222222222222222,
0.5555555555555556,
0.8888888888888888,
0.037037037037037035,
0.37037037037037035,
0.7037037037037037,
0.14814814814814814,
0.48148148148148145,
0.8148148148148148,
0.25925925925925924,
0.5925925925925926,
0.9259259259259259,
0.07407407407407407,
0.4074074074074074,
0.7407407407407407,
0.18518518518518517,
0.5185185185185185,
0.8518518518518519,
0.2962962962962963,
0.6296296296296297,
0.9629629629629629,
0.012345679012345678,
0.345679012345679,
0.6790123456790124,
0.12345679012345678,
0.4567901234567901,
0.7901234567901234,
0.2345679012345679,
0.5679012345679012,
0.9012345679012346,
0.04938271604938271,
0.38271604938271603,
0.7160493827160493,
0.16049382716049382,
0.49382716049382713,
0.8271604938271605,
0.2716049382716049,
0.6049382716049383,
0.9382716049382716,
0.08641975308641975,
0.41975308641975306,
0.7530864197530864,
0.19753086419753085,
0.5308641975308642,
0.8641975308641975,
0.30864197530864196,
0.6419753086419753,
0.9753086419753086,
0.024691358024691357,
0.35802469135802467,
0.691358024691358,
0.13580246913580246,
0.4691358024691358,
0.8024691358024691,
0.24691358024691357,
0.5802469135802469,
0.9135802469135802,
0.06172839506172839,
0.3950617283950617,
0.7283950617283951,
0.1728395061728395,
0.5061728395061729,
0.8395061728395061,
0.2839506172839506,
0.6172839506172839,
0.9506172839506173,
0.09876543209876543,
0.43209876543209874,
0.7654320987654321,
0.20987654320987653,
0.5432098765432098,
0.8765432098765432,
0.32098765432098764,
0.654320987654321,
0.9876543209876543,
0.00411522633744856,
0.3374485596707819,
0.6707818930041153,
0.11522633744855967,
0.448559670781893,
0.7818930041152263,
0.22633744855967078,
0.5596707818930041,
0.8930041152263375,
0.0411522633744856,
0.37448559670781895,
0.7078189300411523,
0.1522633744855967,
0.48559670781893005,
0.8189300411522634,
0.26337448559670784,
0.5967078189300411,
0.9300411522633745,
0.07818930041152264,
0.411522633744856,
0.7448559670781894,
0.18930041152263374,
0.522633744855967,
0.8559670781893004,
0.3004115226337449,
0.6337448559670782,
0.9670781893004116,
0.01646090534979424,
0.3497942386831276,
0.6831275720164609,
0.12757201646090535,
0.4609053497942387,
0.7942386831275721,
0.23868312757201646,
0.5720164609053497,
0.9053497942386831,
0.053497942386831275,
0.3868312757201646,
0.720164609053498,
0.1646090534979424,
0.49794238683127573,
0.831275720164609,
0.2757201646090535,
0.6090534979423868,
0.9423868312757202,
0.09053497942386832,
0.42386831275720166,
0.757201646090535,
0.20164609053497942,
0.5349794238683128,
0.8683127572016461,
0.31275720164609055,
0.6460905349794238,
0.9794238683127572,
0.02880658436213992,
0.36213991769547327,
0.6954732510288066,
0.13991769547325103,
0.4732510288065844,
0.8065843621399177,
0.25102880658436216,
0.5843621399176955,
0.9176954732510288,
0.06584362139917696,
0.3991769547325103,
0.7325102880658436,
0.17695473251028807,
0.5102880658436214,
0.8436213991769548,
0.2880658436213992,
0.6213991769547325,
0.9547325102880658,
0.102880658436214,
0.43621399176954734,
0.7695473251028807,
0.2139917695473251,
0.5473251028806584,
0.8806584362139918,
0.32510288065843623,
0.6584362139917695,
0.9917695473251029,
0.00823045267489712,
0.34156378600823045,
0.6748971193415638,
0.11934156378600823,
0.45267489711934156,
0.7860082304526749,
0.23045267489711935,
0.5637860082304527,
0.897119341563786,
0.04526748971193416,
0.3786008230452675,
0.7119341563786008,
0.15637860082304528,
0.4897119341563786,
0.823045267489712,
0.2674897119341564,
0.6008230452674898,
0.934156378600823,
0.0823045267489712,
0.4156378600823045,
0.7489711934156379,
0.1934156378600823,
0.5267489711934157,
0.8600823045267489,
0.3045267489711934,
0.6378600823045267,
0.9711934156378601,
0.0205761316872428,
0.35390946502057613,
0.6872427983539094,
0.13168724279835392,
0.46502057613168724,
0.7983539094650206,
0.24279835390946503,
0.5761316872427984,
0.9094650205761317,
0.05761316872427984,
0.39094650205761317,
0.7242798353909465,
0.16872427983539096,
0.5020576131687243,
0.8353909465020576,
0.27983539094650206,
0.6131687242798354,
0.9465020576131687,
0.09465020576131687,
0.4279835390946502,
0.7613168724279835,
0.205761316872428,
0.5390946502057613,
0.8724279835390947,
0.3168724279835391,
0.6502057613168725,
0.9835390946502057,
0.03292181069958848,
0.3662551440329218,
0.6995884773662552,
0.1440329218106996,
0.4773662551440329,
0.8106995884773662,
0.2551440329218107,
0.588477366255144,
0.9218106995884774,
0.06995884773662552,
0.40329218106995884,
0.7366255144032922,
0.18106995884773663,
0.51440329218107,
0.8477366255144033,
0.29218106995884774,
0.6255144032921811,
0.9588477366255144,
0.10699588477366255,
0.4403292181069959,
0.7736625514403292,
0.21810699588477367,
0.551440329218107,
0.8847736625514403,
0.3292181069958848,
0.6625514403292181,
0.9958847736625515,
0.0013717421124828531,
0.3347050754458162,
0.6680384087791496,
0.11248285322359397,
0.4458161865569273,
0.7791495198902606,
0.22359396433470508,
0.5569272976680384,
0.8902606310013718,
0.038408779149519894,
0.3717421124828532,
0.7050754458161865,
0.149519890260631,
0.4828532235939643);

struct hitinfo_t {
    /* Index of the first index of the triangle */
    /* or: GROUND_VPTR */
    int hit_vptr;
    /* Intersection distance, barycentric coordinates */
    /* or: intersection distance, 0, texture coordinates (for the ground) */
    vec4 t;
};

struct BVHNode {
    vec4 min;
    vec4 max;
    int nbTriangles;
    int index;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};
layout (std430, binding = 7) buffer VarianceBuffer 
{
    vec4 variances[];
};
layout (std430, binding = 6) buffer MeansBuffer 
{
    vec4 means[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

layout (std430, binding = 5) buffer BVHNodes
{
    BVHNode nodes[];
};


// Check whether there is an intersection between the ray (origin, dir) and the bounding box (bbmin, bbmax), 
// stores into tNear the nearest point of intersection on the ray.
bool intersectBoundingBox(vec4 origin, vec4 dir, vec4 bbmin, vec4 bbmax, out float tNear)
{
	// intersect with BB:
    vec4 sMin = (bbmin - origin) / dir;
    vec4 sMax = (bbmax - origin) / dir;

    vec4 tMin = min(sMin, sMax);
    vec4 tMax = max(sMin, sMax);

    tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);

	if (tNear < 0) tNear = 0; // starting point inside the BVH
    return tNear <= tFar;
}

// intersect ray (origin, dir) with triangle defined by ptr (number inside indexed face set)
// returns a boolean, plus the "t" of hitinfo structure (Intersection distance, barycentric coordinates)
bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
	// vertices from data:
    vec4 v0 = vertices[indices[ptr]];
    vec4 v1 = vertices[indices[ptr + 1]];
    vec4 v2 = vertices[indices[ptr + 2]];

    vec3 e1 = (v1 - v0).xyz;
    vec3 e2 = (v2 - v0).xyz;

    vec3 p = cross(dir.xyz, e2);
    float det = dot(e1, p);
    if (abs(det) < EPS) return false;

    // We do early exit here: as soon as we can return false, we do.
    // In my tests, it is faster than computing all coordinates, 
    // *then* checking validity with a single test. YMMV, feel free to test
    vec3 t = (origin - v0).xyz;
    dist.y = dot(t, p);
    if (dist.y < 0.0 || dist.y > det) return false;
    vec3 q = cross(t, e1);
    dist.z = dot(dir.xyz, q);
    if (dist.z < 0.0 || dist.z > det) return false;
    dist.w = det - dist.y - dist.z;
    if (dist.w < 0.0) return false;
    dist.x = dot(e2, q);
    dist /= det;
    return (dist.x > EPS);
}

bool intersectGround(vec4 origin, vec4 dir, out vec4 dist)
{
    if (abs(dir.y) < EPS)
        return false;
    float t = -(origin.y + groundDistance) / dir.y;

    if (t < MIN_DISTANCE)
        return false;

    vec4 point = origin + t * dir;
    point.y = -groundDistance;
    vec4 scaledPoint = point / radius ;
    vec2 texCoords = 0.5 * scaledPoint.xz + 0.5;

    dist = vec4(t, 0.0, texCoords);

    return true;
}

vec4 interpolateColor(hitinfo_t h)
{
	if (colors.length() > 0) {
		vec4 c0 = colors[indices[h.hit_vptr]];
		vec4 c1 = colors[indices[h.hit_vptr + 1]];
		vec4 c2 = colors[indices[h.hit_vptr + 2]];
		return (h.t.w * c0 + h.t.y * c1 + h.t.z * c2);
	} else return vec4(0.7, 0.7, 0.7, 1.0);
}

vec4 interpolateNormal(hitinfo_t h)
{
	// TODO
    if (normals.length() > 0) {
		vec4 n0 = normals[indices[h.hit_vptr]];
		vec4 n1 = normals[indices[h.hit_vptr + 1]];
		vec4 n2 = normals[indices[h.hit_vptr + 2]];
		return (h.t.w * n0 + h.t.y * n1 + h.t.z * n2);
	} else return vec4(1,0,0,1);
	
}

// BVH-related functions:
bool isLeaf(BVHNode node)
{
    return node.nbTriangles != 0;
}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir, inout hitinfo_t h)
{
    bool hit = false;

    for (int i = 0; i < node.nbTriangles; ++i) {
        int vptr = 3 * (node.index + i);
        vec4 dist;
        if (intersectTriangle(origin, dir, vptr, dist) && dist.x < h.t.x) {
            hit = true;
            h.hit_vptr = vptr;
            h.t = dist;
        }
    }

    return hit;
}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir)
{
    for (int i = 0; i < node.nbTriangles; ++i) {
        int vptr = 3 * (node.index + i);
        vec4 dist;
        if (intersectTriangle(origin, dir, vptr, dist))
            return true;
    }

    return false;
}

#define MAX_STACK_SIZE 64

#define push(stack, size, value) stack[size++] = value
#define pop(stack, size) stack[--size]

bool intersectBVH(vec4 origin, vec4 dir, inout hitinfo_t h)
{
    int rootIndex = 0;
    BVHNode rootNode = nodes[rootIndex];
    float tNear;

    if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
        return false;

    struct StackElement {
        int index;
        float t;
    } stack[MAX_STACK_SIZE];
    int size = 0;

    push(stack, size, StackElement(rootIndex, 0.0));

    bool hit = false;


    while (size != 0) {
        StackElement current = pop(stack, size);
        if (h.t.x < current.t)
            continue;

        BVHNode currentNode = nodes[current.index];
        if (isLeaf(currentNode)) {
            hit = intersectBVHLeaf(currentNode, origin, dir, h) || hit;
        } else {
            StackElement left = StackElement(current.index + 1, 0.0);
            BVHNode leftNode = nodes[left.index];
            bool hitLeft = intersectBoundingBox(origin, dir, leftNode.min, leftNode.max, left.t);

            StackElement right = StackElement(currentNode.index, 0.0);
            BVHNode rightNode = nodes[right.index];
            bool hitRight = intersectBoundingBox(origin, dir, rightNode.min, rightNode.max, right.t);

            if (hitLeft && hitRight) {
                if (left.t < right.t) {
                    push(stack, size, right);
                    push(stack, size, left);
                } else {
                    push(stack, size, left);
                    push(stack, size, right);
                }
            } else if (hitLeft) {
                push(stack, size, left);
            } else if (hitRight) {
                push(stack, size, right);
            }
        }
    }


    return hit;
}

bool intersectBVH(vec4 origin, vec4 dir)
{
    int rootIndex = 0;
    BVHNode rootNode = nodes[rootIndex];
    float tNear;

    if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
        return false;

    int stack[MAX_STACK_SIZE];
    int size = 0;

    push(stack, size, rootIndex);

    while (size != 0) {
        int current = pop(stack, size);
        BVHNode currentNode = nodes[current];
        if (isLeaf(currentNode)) {
            if (intersectBVHLeaf(currentNode, origin, dir))
                return true;
        } else {
            int left = current + 1;
            BVHNode leftNode = nodes[left];
            bool hitLeft = intersectBoundingBox(origin, dir, leftNode.min, leftNode.max, tNear);

            int right = currentNode.index;
            BVHNode rightNode = nodes[right];
            bool hitRight = intersectBoundingBox(origin, dir, rightNode.min, rightNode.max, tNear);

            if (hitLeft && hitRight) {
                push(stack, size, right);
                push(stack, size, left);
            } else if (hitLeft) {
                push(stack, size, left);
            } else if (hitRight) {
                push(stack, size, right);
            }
        }
    }

    return false;
}
// End BVH-related functions
// Gold Noise ©2015 dcerisano@standard3d.com
// - based on the Golden Ratio
// - uniform normalized distribution
// - fastest static noise generator function (also runs at low precision)
// - use with indicated fractional seeding method. 

float PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   

float gold_noise(in vec2 xy, in float seed){
       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}
// Compute the first intersection along the ray (origin, dir). 
// returns the nearest intersection in h
bool firstIntersection(vec4 origin, vec4 dir, out hitinfo_t h)
{
    h.t.x = radius * MAX_SCENE_BOUNDS;

    bool hit = intersectBVH(origin, dir, h);

    vec4 dist;
    if (intersectGround(origin, dir, dist) && dist.x < h.t.x) {
        hit = true;
        h.hit_vptr = GROUND_VPTR;
        h.t = dist;
    }

	return hit;
}

// checks whether there is any intersection along the ray (origin, dir)
// Does not compute the nearest intersection, ends the loop as soon as an intersection is found.
bool isIntersected(vec4 origin, vec4 dir)
{
    vec4 dist;
    return intersectGround(origin, dir, dist) || intersectBVH(origin, dir);
}

// Local illumination related functions. TODO
float fresnelVal (float cos_theta)
{   
    if((pow(eta,2)-(1-pow(cos_theta,2)))<0){
        return 1.0;
    }
    float c_i = sqrt((pow(eta,2)-(1-pow(cos_theta,2))));
    float Fs = pow(abs((cos_theta-c_i)/(cos_theta+c_i)),2);
    float Fp = pow(abs((pow(eta,2)*cos_theta-c_i)/(pow(eta,2)*cos_theta+c_i)),2);
    float F = (Fs+Fp)/2;
    return F;
}
float GGXDistribution(float alpha, float cosTheta) {
    float alpha2 = alpha * alpha;
    float tanTheta = (1.0 - cosTheta) / cosTheta;
    float tanTheta2 = tanTheta * tanTheta;
    float chi = (cosTheta >= 0.0 && cosTheta <= 1.0) ? 1.0 : 0.0;
    float denom = pow(alpha2 + tanTheta2, 2);
    return (alpha2*chi ) / (PI * pow(cosTheta, 4) * denom);
}

float GGXGeometry(float alpha, float cosTheta) {
    float alpha2 = alpha * alpha;
    float tanTheta = (1.0 - cosTheta) / cosTheta;
    float tanTheta2 = tanTheta * tanTheta;
    float r = sqrt(1.0 + alpha2 * tanTheta2);
    return 2.0 / (1.0 + r);
}
vec4 computeSpecular(vec4 color, vec4 p, vec4 n, vec4 v){

    vec3 n_vec = normalize(n.xyz);
    vec3 v_vec = normalize(v.xyz);
    vec3 L_vec = normalize(lightPosition - p.xyz);
    vec3 H_vec = normalize(v_vec + L_vec);

    float cos_theta_i = dot(n_vec, L_vec);
    float cos_theta_o = dot(n_vec, v_vec);
    float cos_theta_h = dot(n_vec, H_vec);
    float cos_theta_d = dot(v_vec, H_vec);


    float F = fresnelVal(cos_theta_d);
    float D = GGXDistribution(roughness, cos_theta_h);
    float G1_i = GGXGeometry(roughness, cos_theta_i);
    float G1_o = GGXGeometry(roughness, cos_theta_o);

    vec4 C_s;
    if (blinnPhong) {
        C_s = F * color.rgba * pow(max(dot(n_vec, H_vec), 0.0), shininess) * lightIntensity;
    } else {
        float G = G1_i * G1_o;
        float specular = (F * D * G) / (4.0 * cos_theta_i * cos_theta_o)*lightIntensity*shininess;
        C_s = vec4(specular * color.rgba);
    }
    return C_s;

}
vec4 directIllumination(vec4 color, vec4 p, vec4 n, vec4 v) {
    // Goal: compute direct illumination at point p, from the light source at lightPosition.
	// color: local material color, RGBA
	// p: coordinates of intersection point, xyzw
	// n: normal at intersection point, xyzw
	// v: incoming viewing direction. Points towards the eye.
    
    //float alpha = 0.05; 
    vec3 n_vec = normalize(n.xyz);
    vec3 v_vec = normalize(v.xyz);
    vec3 L_vec = normalize(lightPosition - p.xyz);
    vec3 H_vec = normalize(v_vec + L_vec);

    vec4 C_a = Ka * color * lightIntensity;

    float cos_theta_i = dot(n_vec, L_vec);
    float cos_theta_o = dot(n_vec, v_vec);
    float cos_theta_h = dot(n_vec, H_vec);
    float cos_theta_d = dot(v_vec, H_vec);
    
    bool isNotVisible1 = isIntersected(p.xyzw, vec4(L_vec.x,L_vec.y,L_vec.z,0.0));
    bool isNotVisible2 = isIntersected(p.xyzw+0.5, vec4(L_vec.x,L_vec.y,L_vec.z,0.0));
    bool isNotVisible= isNotVisible1 && isNotVisible2;


    if (isNotVisible || cos_theta_i<=0) {
        
        return C_a;
    }
    vec4 C_d = Kd * color.rgba * max(dot(n_vec, L_vec), 0.0) * lightIntensity;

    


    float F = fresnelVal(cos_theta_d);
    float D = GGXDistribution(roughness, cos_theta_h);
    float G1_i = GGXGeometry(roughness, cos_theta_i);
    float G1_o = GGXGeometry(roughness, cos_theta_o);

    vec4 C_s;
    if (blinnPhong) {
        C_s = F * color.rgba * pow(max(dot(n_vec, H_vec), 0.0), shininess) * lightIntensity;
    } else {
        float G = G1_i * G1_o;
        float specular = (F * D * G) / (4.0 * cos_theta_i * cos_theta_o)*lightIntensity;
        C_s = vec4(specular * color.rgba);
    }

    return C_a + C_d + C_s;
}

const int MAX_TRACE = 4;

void getLocal(vec4 origin, vec4 dir, hitinfo_t h, out vec4 color, out vec4 p, out vec4 n)
{
    p = origin + h.t.x * dir;
    if (h.hit_vptr == GROUND_VPTR) {
        color = texture(colorTexture, h.t.pq);
        p.y = -groundDistance;
        n = vec4(0.0, 1.0, 0.0, 0.0);
    } else {
        color = interpolateColor(h);
        n = interpolateNormal(h);
    }
}


struct trace_state_t
{
    vec4 origin;  // start of ray
    vec4 dir;     // direction
    vec4 color;   // color after multiple bounces
    vec4 localColor;   // color of the material (after interpolation)
    vec4 brdf;
    hitinfo_t h;  // what the ray hits (triangle Id, u, v, lambda)
    vec4 hit;     // point the ray hits 
    vec4 Ld;      // direction to light at destination
    vec4 N;       // normal at destination
};

vec4 reflectVector(vec4 i, vec4 n) {
    // Normalize the incident vector and the normal vector
    vec3 i_vec = normalize(i.xyz);
    vec3 n_vec = normalize(n.xyz);

    
    float dot_product = dot(i_vec, n_vec);

    
    vec3 r_vec = i_vec - 2.0 * dot_product * n_vec;

    
    return vec4(r_vec, 0.0);
}

vec4 trace(vec4 origin, vec4 dir)
{
    // These are for TP2:
    trace_state_t stack[MAX_TRACE + 1];
    bool fallback[MAX_TRACE + 1];
    int sp = 0;

    // These are for TP1:
    hitinfo_t hl;
    vec4 hit;
    vec4 localColor;
    vec4 N;
    float ratio = 0.25;

    if (firstIntersection(origin, dir, hl)) {
        getLocal(origin, dir, hl, localColor, hit, N);
        trace_state_t curr;
        curr.origin = origin;
        curr.dir = dir;
        curr.localColor = localColor;
        curr.color = localColor;
        curr.h = hl;
        curr.hit = hit;
        curr.Ld = vec4(normalize(lightPosition - hit.xyz), 0.0);
        curr.N = N;
        stack[0] = curr;
        fallback[0] = true;

        // Forward tracing
        for (int i = 0; i < MAX_TRACE && fallback[i]; i++) {
            vec4 hit_r;
            vec4 localColor_r;
            vec4 N_r;
            vec4 ref = reflectVector(stack[i].dir, stack[i].N);
            hitinfo_t hr;
            if (firstIntersection(stack[i].hit, ref, hr)) {
                getLocal(stack[i].hit, ref, hr, localColor_r, hit_r, N_r);
                trace_state_t newState;
                newState.origin = stack[i].hit;
                newState.dir = ref;
                newState.localColor = localColor_r;
                newState.color = localColor_r;
                newState.h = hr;
                newState.hit = hit_r;
                newState.Ld = vec4(normalize(lightPosition - hit_r.xyz), 0.0);
                newState.N = N_r;
                stack[i + 1] = newState;
                
                fallback[i + 1] = true;
            } else{
                fallback[i+1] =false;
            }
        }

        // Backward color computing
        
        for (int j = MAX_TRACE; j >= 0; j--) {
            if (fallback[j]) {
                trace_state_t current = stack[j];
                current.color = directIllumination(current.localColor, current.hit, current.N, -current.dir);
                current.brdf=computeSpecular(current.localColor, current.hit, current.N, -current.dir);
                if (j < MAX_TRACE && fallback[j+1]) {
                    vec3 n_vec=normalize(stack[j+1].N.xyz);
                    vec3 v_vec=normalize(-stack[j+1].dir.xyz);
                    float cos_theta= max(dot(v_vec,n_vec),0.1);
                    float F = fresnelVal(cos_theta);
                    current.color = current.color+F*(stack[j + 1].color); 
                } 
                stack[j] = current; 
            }
        }
        
        return stack[0].color;
        
           
       
    }

    return vec4(0, 0, 0, 1);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
	// Convert local screen coordinates into world coordinates
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    vec2 pix_2 = vec2(pix);
    ivec2 size = imageSize(framebuffer);
    vec2 rand = vec2(time*854,time*24);
    vec4 previousVariance = vec4(0,0,0,0);
    vec4 previousMean = vec4(0,0,0,0);
    if (time != 0) {
        
        previousVariance = variances[x * MAX_HEIGHT + y];
        previousMean = means[x * MAX_HEIGHT + y];
        if((sqrt(previousVariance.r)< (previousMean.r/10))&&(sqrt(previousVariance.g)< (previousMean.g/10))&&(sqrt(previousVariance.b)< (previousMean.b/10))){
            return;
        }
    }

    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    if(quasiRandom){
        pix_2.x+=haltons[int(time) % 256];
        pix_2.y+=haltons[int(time-1) % 256];
    }else{
        pix_2.x+=min(0.5,max(-0.5,gold_noise(rand,time*56)));
        pix_2.y+=min(0.5,max(-0.5,gold_noise(rand,time*42)));
    }


    vec2 pos = pix_2 / (size - vec2(0.5, 0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1., 1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);
    vec4 prev_col= imageLoad(framebuffer, pix);
    vec4 variance = vec4(0,0,0,0);
    if (time != 0) {
        variance = ((previousVariance * (time - 1)) + ((color - prev_col) * (color - prev_col))) / time;
    }

    color = (color/(time+1))+((prev_col*time)/(time+1));
    variances[x * MAX_HEIGHT + y] = variance;
    means[x * MAX_HEIGHT + y]=color;
    imageStore(framebuffer, pix, color);
}
